import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import TerminalPane from './TerminalPane';
import { Box, Typography } from '@mui/material';

type Credentials = {
    ip: string;
    username: string;
    sshKey: string;
};

type Pane = {
    id: string;
    credentials?: Credentials;
    splitDirection?: 'horizontal' | 'vertical';
    children?: [Pane, Pane];
};

interface SplitTerminalProps {
    credentials: Credentials;
}

let paneIdCounter = 0;

const LAYOUT_KEY = 'terminal_layout';
const LAYOUT_TIMESTAMP_KEY = 'terminal_layout_timestamp';
const LAYOUT_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

// Wrapper component that creates stable callbacks per pane
const MemoizedTerminalPane = React.memo(({
    paneId,
    ip,
    username,
    sshKey,
    onSplit,
    onClose,
    canClose
}: {
    paneId: string;
    ip: string;
    username: string;
    sshKey: string;
    onSplit: (paneId: string, direction: 'horizontal' | 'vertical') => void;
    onClose: (paneId: string) => void;
    canClose: boolean;
}) => {
    console.log(`[MemoizedTerminalPane] Rendering pane: ${paneId}`);

    // Create stable callbacks for this specific pane
    const handleSplitHorizontal = useCallback(() => {
        console.log(`[MemoizedTerminalPane] Split horizontal called for: ${paneId}`);
        onSplit(paneId, 'horizontal');
    }, [onSplit, paneId]);

    const handleSplitVertical = useCallback(() => {
        console.log(`[MemoizedTerminalPane] Split vertical called for: ${paneId}`);
        onSplit(paneId, 'vertical');
    }, [onSplit, paneId]);

    const handleClose = useCallback(() => {
        console.log(`[MemoizedTerminalPane] Close called for: ${paneId}`);
        onClose(paneId);
    }, [onClose, paneId]);

    return (
        <TerminalPane
            ip={ip}
            username={username}
            sshKey={sshKey}
            paneId={paneId}
            onSplitHorizontal={handleSplitHorizontal}
            onSplitVertical={handleSplitVertical}
            canClose={canClose}
            onClosePane={handleClose}
        />
    );
}, (prev, next) => {
    // Only re-render if these props change
    // Ignore canClose, onSplit, and onClose as they don't require reconnection
    const shouldSkip = (
        prev.paneId === next.paneId &&
        prev.ip === next.ip &&
        prev.username === next.username &&
        prev.sshKey === next.sshKey
    );

    console.log(`[MemoizedTerminalPane] Memo check for ${next.paneId}: ${shouldSkip ? 'SKIP re-render' : 'ALLOW re-render'}`);

    return shouldSkip;
});

export default function SplitTerminal({ credentials }: SplitTerminalProps) {
    // Initialize from saved layout or create new
    const initializePane = (): Pane => {
        try {
            const savedLayout = sessionStorage.getItem(LAYOUT_KEY);
            const timestamp = sessionStorage.getItem(LAYOUT_TIMESTAMP_KEY);

            if (savedLayout && timestamp) {
                const age = Date.now() - parseInt(timestamp);
                if (age < LAYOUT_EXPIRY) {
                    const layout = JSON.parse(savedLayout);
                    // Restore credentials in all panes
                    const restoreCredentials = (pane: Pane): Pane => {
                        if (pane.children) {
                            return {
                                ...pane,
                                children: [
                                    restoreCredentials(pane.children[0]),
                                    restoreCredentials(pane.children[1])
                                ] as [Pane, Pane]
                            };
                        }
                        return { ...pane, credentials };
                    };

                    // Update counter to avoid ID conflicts
                    const updateCounter = (pane: Pane) => {
                        const idNum = parseInt(pane.id.split('-')[1]);
                        if (idNum >= paneIdCounter) {
                            paneIdCounter = idNum + 1;
                        }
                        if (pane.children) {
                            updateCounter(pane.children[0]);
                            updateCounter(pane.children[1]);
                        }
                    };

                    const restoredLayout = restoreCredentials(layout);
                    updateCounter(restoredLayout);
                    return restoredLayout;
                }
            }
        } catch (error) {
            console.error('Failed to restore layout:', error);
        }

        // Default single pane
        return {
            id: `pane-${paneIdCounter++}`,
            credentials,
        };
    };

    const [rootPane, setRootPane] = useState<Pane>(initializePane());
    const [focusedPaneId, setFocusedPaneId] = useState<string>(rootPane.id);

    // Save layout to sessionStorage whenever it changes
    useEffect(() => {
        try {
            // Remove credentials before saving (security)
            const stripCredentials = (pane: Pane): any => {
                if (pane.children) {
                    return {
                        id: pane.id,
                        splitDirection: pane.splitDirection,
                        children: [
                            stripCredentials(pane.children[0]),
                            stripCredentials(pane.children[1])
                        ]
                    };
                }
                return { id: pane.id };
            };

            const layoutToSave = stripCredentials(rootPane);
            sessionStorage.setItem(LAYOUT_KEY, JSON.stringify(layoutToSave));
            sessionStorage.setItem(LAYOUT_TIMESTAMP_KEY, Date.now().toString());
        } catch (error) {
            console.error('Failed to save layout:', error);
        }
    }, [rootPane]);

    // Keyboard shortcuts
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // Cmd/Ctrl + D: Split horizontally
            if ((e.metaKey || e.ctrlKey) && e.key === 'd') {
                e.preventDefault();
                splitPane(focusedPaneId, 'horizontal');
            }
            // Cmd/Ctrl + Shift + D: Split vertically
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                splitPane(focusedPaneId, 'vertical');
            }
            // Cmd/Ctrl + W: Close pane
            if ((e.metaKey || e.ctrlKey) && e.key === 'w') {
                if (countPanes(rootPane) > 1) {
                    e.preventDefault();
                    closePane(focusedPaneId);
                }
            }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [focusedPaneId, rootPane]);

    const splitPane = useCallback((paneId: string, direction: 'horizontal' | 'vertical') => {
        // Create new pane ID
        const newPaneId = `pane-${paneIdCounter++}`;

        setRootPane(prev => {
            const transformPane = (pane: Pane): Pane => {
                // If this is the pane we're splitting
                if (!pane.children && pane.id === paneId) {
                    const newPane: Pane = {
                        id: newPaneId,
                        credentials: pane.credentials,
                    };

                    // Create container with NEW id, but keep children array stable
                    // This is key: we don't modify the original pane object at all
                    const containerId = `pane-${paneIdCounter++}`;
                    return {
                        id: containerId,
                        splitDirection: direction,
                        children: [
                            pane, // EXACT same object - no spread, no modification
                            newPane,
                        ] as [Pane, Pane]
                    };
                }

                // For containers, recursively transform
                if (pane.children) {
                    const child0 = transformPane(pane.children[0]);
                    const child1 = transformPane(pane.children[1]);

                    // Only create new object if children actually changed
                    if (child0 !== pane.children[0] || child1 !== pane.children[1]) {
                        return {
                            ...pane,
                            children: [child0, child1] as [Pane, Pane]
                        };
                    }
                }

                // Return same reference if nothing changed
                return pane;
            };

            return transformPane(prev);
        });
        setFocusedPaneId(newPaneId);
    }, []);

    const closePane = useCallback((paneId: string) => {
        setRootPane(prev => {
            // Cannot close if this is the only pane
            if (prev.id === paneId && !prev.children) {
                return prev;
            }

            // Special case: if we're closing a direct child of root
            if (prev.children && (prev.children[0].id === paneId || prev.children[1].id === paneId)) {
                const remainingChild = prev.children.find(child => child.id !== paneId);
                if (remainingChild) {
                    setFocusedPaneId(remainingChild.children ? findFirstLeafPane(remainingChild)?.id || remainingChild.id : remainingChild.id);
                    return { ...remainingChild };
                }
            }

            const newRootPane = JSON.parse(JSON.stringify(prev));
            const parent = findParentPane(newRootPane, paneId);

            if (parent && parent.children) {
                const remainingChild = parent.children.find((child: Pane) => child.id !== paneId);
                if (remainingChild) {
                    // Replace parent with remaining child's properties
                    parent.id = remainingChild.id;
                    parent.credentials = remainingChild.credentials;
                    parent.children = remainingChild.children;
                    parent.splitDirection = remainingChild.splitDirection;
                }
            }

            return newRootPane;
        });

        // Update focus if closing the focused pane
        setFocusedPaneId(prev => {
            if (prev === paneId) {
                const firstPane = findFirstLeafPane(rootPane);
                return firstPane?.id || prev;
            }
            return prev;
        });
    }, [rootPane, focusedPaneId]);

    const findFirstLeafPane = (pane: Pane): Pane | null => {
        if (!pane.children) {
            return pane;
        }
        return findFirstLeafPane(pane.children[0]);
    };

    const findPane = (pane: Pane, id: string): Pane | null => {
        if (pane.id === id) return pane;
        if (pane.children) {
            return findPane(pane.children[0], id) || findPane(pane.children[1], id);
        }
        return null;
    };

    const findParentPane = (pane: Pane, childId: string): Pane | null => {
        if (pane.children) {
            if (pane.children[0].id === childId || pane.children[1].id === childId) {
                return pane;
            }
            return findParentPane(pane.children[0], childId) || findParentPane(pane.children[1], childId);
        }
        return null;
    };

    const renderPane = (pane: Pane): React.ReactNode => {
        if (pane.children) {
            const isHorizontal = pane.splitDirection === 'horizontal';
            return (
                <Box
                    key={`container-${pane.id}`}
                    sx={{
                        display: 'flex',
                        flexDirection: isHorizontal ? 'row' : 'column',
                        width: '100%',
                        height: '100%',
                        gap: '2px',
                    }}
                >
                    <Box key={`wrapper-${pane.children[0].id}`} sx={{ flex: 1, minWidth: 0, minHeight: 0 }}>
                        {renderPane(pane.children[0])}
                    </Box>
                    <Box key={`wrapper-${pane.children[1].id}`} sx={{ flex: 1, minWidth: 0, minHeight: 0 }}>
                        {renderPane(pane.children[1])}
                    </Box>
                </Box>
            );
        }

        const isFocused = pane.id === focusedPaneId;
        const canClose = countPanes(rootPane) > 1;

        // Render terminal directly in the tree
        return (
            <Box
                key={`pane-wrapper-${pane.id}`}
                data-pane-id={pane.id}
                sx={{
                    position: 'relative',
                    width: '100%',
                    height: '100%',
                    border: isFocused ? '2px solid #0073bb' : '2px solid transparent',
                    transition: 'border-color 0.2s',
                }}
                onClick={() => setFocusedPaneId(pane.id)}
            >
                {/* Render terminal component directly - React will preserve it by paneId key */}
                {pane.credentials && (
                    <MemoizedTerminalPane
                        key={pane.id}
                        ip={pane.credentials.ip}
                        username={pane.credentials.username}
                        sshKey={pane.credentials.sshKey}
                        paneId={pane.id}
                        onSplit={splitPane}
                        onClose={closePane}
                        canClose={canClose}
                    />
                )}
            </Box>
        );
    };

    const countPanes = (pane: Pane): number => {
        if (pane.children) {
            return countPanes(pane.children[0]) + countPanes(pane.children[1]);
        }
        return 1;
    };

    // Get all leaf panes
    const allPanes = collectPanes(rootPane);
    const canClose = countPanes(rootPane) > 1;

    return (
        <Box
            sx={{
                position: 'fixed',
                inset: 0,
                width: '100vw',
                height: '100vh',
                background: '#000',
                overflow: 'hidden',
            }}
        >
            {/* Render layout structure */}
            {renderPaneLayout(rootPane)}

            {/* Render all terminals at the same tree level (prevents unmount on split) */}
            {allPanes.map(pane => pane.credentials && (
                <Box
                    key={`terminal-${pane.id}`}
                    sx={{
                        position: 'absolute',
                        inset: 0,
                        pointerEvents: 'none', // Let clicks pass through to placeholder
                    }}
                >
                    <Box
                        sx={{
                            position: 'absolute',
                            ...getP anePosition(pane.id, rootPane),
                            pointerEvents: 'auto',
                        }}
                    >
                        <MemoizedTerminalPane
                            key={pane.id}
                            ip={pane.credentials.ip}
                            username={pane.credentials.username}
                            sshKey={pane.credentials.sshKey}
                            paneId={pane.id}
                            onSplit={splitPane}
                            onClose={closePane}
                            canClose={canClose}
                        />
                    </Box>
                </Box>
            ))}

            {/* Keyboard shortcuts help */}
            <Box
                sx={{
                    position: 'fixed',
                    bottom: 8,
                    left: 8,
                    background: 'rgba(0, 0, 0, 0.8)',
                    color: '#888',
                    padding: '6px 12px',
                    borderRadius: 1,
                    fontSize: '11px',
                    fontFamily: 'monospace',
                    display: 'flex',
                    gap: 2,
                    opacity: 0.5,
                    transition: 'opacity 0.2s',
                    '&:hover': { opacity: 1 },
                }}
            >
                <span>⌘D Split H</span>
                <span>⌘⇧D Split V</span>
                <span>⌘W Close</span>
            </Box>
        </Box>
    );
}
